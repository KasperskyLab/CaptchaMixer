// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace Kaspersky.CaptchaMixer;

/// <summary>
/// Base class for area segmentation creators.
/// </summary>
public abstract class AreaSegmentationCreator : AreaBasedVectorObjectsCreator
{
	/// <summary>
	/// Segments count.
	/// </summary>
	public ValueProvider<int> Segments { get; set; } = 2;

	/// <summary>
	/// Deviation on the first base line of snap points.
	/// </summary>
	public ValueProvider<float> OffsetSnapsLine1 { get; set; } = 0;

	/// <summary>
	/// Deviation on the second base line of snap points.
	/// </summary>
	public ValueProvider<float> OffsetSnapsLine2 { get; set; } = 0;

	/// <summary>
	/// Sets <see cref="OffsetSnapsLine1"/> and <see cref="OffsetSnapsLine2"/>.
	/// </summary>
	public ValueProvider<float> OffsetSnaps
	{
		set
		{
			OffsetSnapsLine1 = value;
			OffsetSnapsLine2 = value;
		}
	}

	protected AreaSegmentationCreator() { }

	/// <param name="segments"><inheritdoc cref="Segments" path="/summary"/></param>
	/// <exception cref="ArgumentNullException"/>
	protected AreaSegmentationCreator(ValueProvider<int> segments)
		=> Segments = segments ?? throw new ArgumentNullException(nameof(segments));

	public override void Process(RectangleF area, IVectorLayer layer, ICaptchaContext context)
	{
		int segments = Segments;
		if (segments < 2)
			throw new ArgumentException("Segments count must be >= 2");

		var vectorObject = new VectorObject();

		// how this works:
		// - descendant inplementation gives us two base lines (line1 and line2) for th specified area
		// - we then choose base points on those base lines - these are "line snaps"
		// - the area is cut into segments by creating separators between snaps of line1 and line2;
		//   the shape of separators is also defined by descendants

		var line1 = GetLine1(area);
		var line2 = GetLine2(area);

		var snapsCount = segments - 1;
		var line1Snaps = GetLineSnaps(line1, snapsCount, OffsetSnapsLine1);
		var line2Snaps = GetLineSnaps(line2, snapsCount, OffsetSnapsLine2);

		var separators = Enumerable
			.Range(0, snapsCount)
			.Select(i => GetSeparator(line1Snaps[i], line2Snaps[i]))
			.ToList();

		// the first segment is based on the first separator and two start points on base lines
		vectorObject.Paths.Add(
			new VectorPath(new VectorPathInstruction[]
			{
				new MoveToInstruction(line1Snaps[0]),
				separators[0],
				new LineToInstruction(line2.point1),
				new LineToInstruction(line1.point1),
				new LineToInstruction(line1Snaps[0]),
				new CloseInstruction()
			}));

		// non-edge segments are build from two separators and parts of base lines between them.
		// since the separator instruction which is generated by descendant is drawn from line1 to line2,
		// next time it must be drawn in reversed direction.
		for (var i = 1; i < segments - 1; i++)
			vectorObject.Paths.Add(
				new VectorPath(new VectorPathInstruction[]
				{
					new MoveToInstruction(line1Snaps[i - 1]),
					separators[i - 1],
					new LineToInstruction(line2Snaps[i]),
					separators[i].Reverse(line1Snaps[i]),
					new LineToInstruction(line1Snaps[i - 1]),
					new CloseInstruction()
				}));

		// the last segment is based on the last separator and end points of base lines
		var lastSnapIndex = snapsCount - 1;
		vectorObject.Paths.Add(
			new VectorPath(new VectorPathInstruction[]
			{
				new MoveToInstruction(line1Snaps[lastSnapIndex]),
				separators[lastSnapIndex],
				new LineToInstruction(line2.point2),
				new LineToInstruction(line1.point2),
				new LineToInstruction(line1Snaps[lastSnapIndex]),
				new CloseInstruction()
			}));

		layer.Objects.Add(vectorObject);
	}

	private static List<Vector2> GetLineSnaps((Vector2, Vector2) line, int snapsCount, ValueProvider<float> offsetProvider)
	{
		var (point1, point2) = line;

		var lineLength = VectorMath.LineLength(point1, point2);
		var defaultSegmentLength = lineLength / (snapsCount + 1);
		var segments = Enumerable
			.Range(1, snapsCount)
			.Select(i => defaultSegmentLength * i + offsetProvider)
			.ToList();

		// by default a base line is split on equal parts.
		// however an offset may be provided and thus we must ensure that:
		// 1. the first and last points haven't gone beyond base line:
		segments[0] = Math.Max(segments[0], 0);
		segments[^1] = Math.Min(segments[^1], lineLength);
		// 2. each next point hasn't gone beyond the previous one:
		for (var i = 1; i < segments.Count; i++)
			segments[i] = Math.Max(segments[i], segments[i - 1]);

		// normalize sizes to line length
		for (var i = 0; i < segments.Count; i++)
			segments[i] = segments[i] / lineLength;

		var dx = point2.X - point1.X;
		var dy = point2.Y - point1.Y;
		return segments
			.Select(s => new Vector2(point1.X + dx * s, point1.Y + dy * s))
			.ToList();
	}

	protected abstract (Vector2 point1, Vector2 point2) GetLine1(RectangleF area);
	protected abstract (Vector2 point1, Vector2 point2) GetLine2(RectangleF area);
	protected abstract VectorPathInstruction GetSeparator(Vector2 from, Vector2 to);
}
